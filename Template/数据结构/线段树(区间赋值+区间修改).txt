struct Info {
    i64 sum = 0;
};

struct Lazy {
    i64 add = 0, setL = 0;
    bool need = false;
};

Info operator+(const Info &l, const Info &r) {
    Info res;
    res.sum = l.sum + r.sum;
    return res;
}

struct SegmentTree {
    int n;
    vector<Info> info;
    vector<Lazy> lazy;

    SegmentTree() {}
    SegmentTree(int _n) {
        init(_n);
    }

    void init(int _n){
        n = _n;
        info.assign(n << 2, Info());
        lazy.assign(n << 2, Lazy());
        build(1, 1, n);
    }

    void applyAdd(int p, int len, i64 val){
        info[p].sum += val * len;
        lazy[p].add += val;
    }

    void applySet(int p, int len, i64 val){
        info[p].sum = val * len;
        lazy[p] = Lazy(0, val, true);
    }
    //如果同时有重置信息和添加信息，那么一定是先重置，不然add将无效
    void down(int p, int sizL, int sizR){
        if(lazy[p].need){
            applySet(2 * p, sizL, lazy[p].setL);
            applySet(2 * p + 1, sizR, lazy[p].setL);
            lazy[p].need = false;
        }
        if(lazy[p].add != 0){
            applyAdd(2 * p, sizL, lazy[p].add);
            applyAdd(2 * p + 1, sizR, lazy[p].add);
            lazy[p].add = 0;
        }
    }

    void up(int p){
        info[p] = info[2 * p] + info[2 * p + 1];
    }

    void build(int p, int l, int r){
        if (l == r){
            info[p] = Info(0);
        }else{
            int mid = (l + r) / 2;
            build(2 * p, l, mid);
            build(2 * p + 1, mid + 1, r);
            up(p);
        }
    }
    void modify(int p, int l, int r, int L, int R, i64 val, int sign){
        if (L > r || R < l){
            return;
        }
        if (L <= l && r <= R){
            if(sign == 1)
                applyAdd(p, r - l + 1, val);
            if(sign == 2)
                applySet(p, r - l + 1, val);
        }else{
            int mid = (l + r) / 2;
            down(p, mid - l + 1, r - mid);
            modify(2 * p, l, mid, L, R, val, sign);
            modify(2 * p + 1, mid + 1, r, L, R, val, sign);
            up(p);
        }
    }

    Info query(int p, int l, int r, int L, int R){
        if(L > r || R < l){
            return Info();
        }
        Info res;
        if(L <= l && r <= R){
            res = info[p];
        }else{
            int mid = (l + r) / 2;
            down(p);
            res = query(2 * p, l, mid, L, R) + query(2 * p + 1, mid + 1, r, L, R);
        }
        return res;
    }

    //1-based
    void modify(int L, int R, i64 val, int sign){ 
        modify(1, 1, n, L, R, val, sign);
    }
    Info query(int L, int R){
        return query(1, 1, n, L, R);
    }
};