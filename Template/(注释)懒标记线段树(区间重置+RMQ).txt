using i64 = long long;

struct Info{//主要信息
    i64 mx;
    Info(int x = 0) : mx(x) {}
};

struct Lazy{//懒信息
    i64 add, setL;
    bool need;
    Lazy(i64 x1 = 0, i64 x2 = 0, bool x3 = false) : add(x1), setL(x2), need(x3) {}
};

Info operator+(const Info &a, const Info &b){//合并两个子区间的规则
    if(a.mx >= b.mx)
        return a;
    if(b.mx > a.mx)
        return b;
}

struct SegmentTree{
    int n;
    vector<Info> info;
    vector<Lazy> lazy;

    SegmentTree() {}
    SegmentTree(int _n) {
        init(_n);
    }

    void init(int _n){
        n = _n;
        info.assign(n << 2, Info());
        lazy.assign(n << 2, Lazy());
        build(1, 1, n);
    }
    //对i节点进行+v的懒操作
    void applyAdd(int p, i64 val){
        info[p].mx += val;
        lazy[p].add += val;
    }
    //对i节点进行=v的懒操作
    void applySet(int p, i64 val){
        info[p].mx = val;
        lazy[p] = Lazy(0, val, true);
    }
    //懒信息下发，对左右进行懒操作，然后清空本身的懒标记，
    //如果同时有重置信息和添加信息，那么一定是先重置，不然add将无效
    void down(int p){
        if(lazy[p].need){
            applySet(2 * p, lazy[p].setL);
            applySet(2 * p + 1, lazy[p].setL);
            lazy[p].need = false;
        }
        if(lazy[p].add != 0){
            applyAdd(2 * p, lazy[p].add);
            applyAdd(2 * p + 1, lazy[p].add);
            lazy[p].add = 0;
        }
    }
    //回溯，更新i的值
    void up(int p){
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    //构建线段树 O(N)
    void build(int p, int l, int r){
        if (l == r){
            info[p] = Info(0);
        }else{
            int mid = (l + r) / 2;
            build(2 * p, l, mid);
            build(2 * p + 1, mid + 1, r);
            up(p);//回溯更新info[i]
        }
    }
    //区间修改与重置(下标为0) 最坏2*O(logN)
    void modify(int p, int l, int r, int L, int R, i64 val, int sign){
        if (L > r || R < l)
            return;

        if (L <= l && r <= R){//l~r被ql~qr完全包含时，进行懒操作，不用往下递归了
            if(sign == 1)//增加
                applyAdd(p, val);
            if(sign == 2)//重置
                applySet(p, val);
        }else{
            int mid = (l + r) / 2;
            down(p);//l~r不完全被ql~qr包含，懒信息下发
            modify(2 * p, l, mid, L, R, val, sign);
            modify(2 * p + 1, mid + 1, r, L, R, val, sign);
            up(p);//回溯
        }
    }
    //区间查询(下标为0) 最坏2*O(logN) 注意: 不需要回溯
    i64 query(int p, int l, int r, int L, int R){
        i64 res = -1e17;
        if(L > r || R < l)
            return res;
        if(L <= l && r <= R){//l~r被ql~qr完全包含时，直接返回整段值，不用往下递归了
            res = info[p].mx;
        }else{
            int mid = (l + r) / 2;
            down(p);//l~r不完全被ql~qr包含，懒信息下发
            res = max(res, query(2 * p, l, mid, L, R));
            res = max(res, query(2 * p + 1, mid + 1, r, L, R));
        }
        return res;
    }

    //0-based
    void modify(int L, int R, i64 val, int sign){ 
        if(L <= R)
            modify(1, 1, n, L + 1, R + 1, val, sign);
    }
    i64 query(int L, int R){
        if(L <= R)
            return query(1, 1, n, L + 1, R + 1);
    }
};