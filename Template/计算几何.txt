const double pi = acos(-1);
const int N = 5000 + 10;
const double dinf = 1e18, eps = 1e-9;

int sgn(double x) { return x < -eps ? -1 : x > eps; }

struct Point {
    double x, y;
    Point() {}
    Point(double x, double y) : x(x), y(y) {}

    Point operator+(Point B) { return Point(x + B.x, y + B.y); } // 向量加法
    Point operator-(Point B) { return Point(x - B.x, y - B.y); } // 向量减法
    Point operator*(double k) { return Point(x * k, y * k); }    // 向量乘法
    Point operator/(double k) { return Point(x / k, y / k); }    // 向量除法

    bool operator==(Point B) { return sgn(x - B.x) == 0 && sgn(y - B.y) == 0; } // 判断向量是否相等
};

struct Line {
    Point a, b;
};

double dot(Point a, Point b) { // 点积
    return a.x * b.x + a.y * b.y;
}

double Atan2(Line p) { // 返回线段的 arctan 值
    return atan2(p.b.y - p.a.y, p.b.x - p.a.x);
}

double cross(Point a, Point b) { // 叉积
    return a.x * b.y - a.y * b.x;
}

bool jijiao(Line p, Line q) { // 极角排序 + 左侧排序
    double P = Atan2(p), Q = Atan2(q);
    return fabs(P - Q) > eps ? P < Q : cross(p.b - p.a, q.b - p.a) < 0;
}

double cross_1(Point a, Point b, Point c) { // 点线关系( 负则ab在ac左边 正则ab在ac右边 )
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

bool Onright(Line a, Point p) { // p 是否在 a 的右边
    return cross((a.b - a.a), (p - a.a)) < 0;
}

bool right(Point a, Point L, Point R) { // 判断AL是否在AR右边
    return sgn(cross(L - a, R - a)) > 0; // 必须严格大于零
}

double len(Point a) { // 求模长
    return sqrtl(a.x * a.x + a.y * a.y);
}

double dis(Point a, Point b) { // 两点间距离的平方
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

double dis_PL(Point p, Point a, Point b) { // p到线段AB的距离
    if (a == b) return len(p - a); // AB重合
    Point x = p - a, y = p - b, z = b - a;
    if (sgn(dot(x, z)) < 0) return len(x);
    if (sgn(dot(y, z)) > 0) return len(y);
    return fabs(cross(x, z) / len(z));
}

Point FootPoint(Point p, Point a, Point b) { // p到AB的垂足
    Point x = p - a, y = p - b, z = b - a;
    double len1 = dot(x, z) / len(z);
    double len2 = -1.0 * dot(y, z) / len(z); // BP在AB的投影
    return a + z * (len1 / (len1 + len2)); // AP在AB的投影 成比例
}

double angle(Point a, Point b) { // 求夹角[1,180]
    return acos(dot(a, b) / len(a) / len(b));
}

double angle360(const Point &A, const Point &B) {
    double a0 = atan2(A.y, A.x);
    double b0 = atan2(B.y, B.x);
    double d = b0 - a0;
    if (d < 0) d += 2 * pi;
    return d;
}

Point getNode(Point a, Point b, Point c, Point d) { // 两直线AB,CD的交点
    Point x = b - a, y = d - c, z = a - c;
    return a + x * (cross(y, z) / cross(x, y)); // 点A加上向量AF
}

Point getNodeL(Line p, Line q) { // 两直线交点
    Point u = p.a - q.a, v = p.b - p.a, w = q.b - q.a;
    double t = cross(u, w) / cross(w, v);
    return p.a + v * t;
}

int checkP(Point p, Point a, Point b) { // 判断点P是否在线段AB上
    return !sgn(cross(p - a, b - a)) && sgn(dot(p - a, p - b)) <= 0;
    /*PA,AB共线且P在AB之间(其实也可以用len(p-a)+len(p-b)==len(a-b)判断，但是精度损失较大)*/
}

int checkLine(Point a, Point b, Point c, Point d) { // 判断直线AB与线段CD是否相交
    return checkP(getNode(a, b, c, d), c, d); // 直线AB与直线CD的交点在线段CD上
}

int checkLine_1(Point a, Point b, Point c, Point d) { // 判断两线段AB,CD是否相交
    double c1 = cross(b - a, c - a), c2 = cross(b - a, d - a);
    double d1 = cross(d - c, a - c), d2 = cross(d - c, b - c);
    return sgn(c1) * sgn(c2) < 0 && sgn(d1) * sgn(d2) < 0; // 分别在两侧
}

double dis2(Point a, Point b) { // 两点间距离
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

/* ---------------- 凸包（Andrew）相关 ---------------- */

int top; // 凸包栈指针
vector<Point> p(N), s(N); // p 为输入点数组（1..n），s 为凸包栈

bool Tubaocmp(Point a, Point b) { // 排序
    return a.x != b.x ? a.x < b.x : a.y < b.y;
}

double Andrew(int n) { // Andrew 无法处理只有一个或两个点的情况(特判一下)
    sort(p.begin() + 1, p.begin() + n + 1, Tubaocmp);
    for (int i = 1; i <= n; i++) { // 下凸包
        while (top > 1 && cross_1(s[top - 1], s[top], p[i]) <= 0) top--;
        s[++top] = p[i];
    }
    int t = top;
    for (int i = n - 1; i >= 1; i--) { // 上凸包
        while (top > t && cross_1(s[top - 1], s[top], p[i]) <= 0) top--;
        s[++top] = p[i];
    }
    double ans = 0;
    for (int i = 1; i < top; i++) {
        ans += dis2(s[i], s[i + 1]);
    }
    top--; // top记得减一
    return ans;
}

/* ---------------- 二分凸包判点（InTubao） ---------------- */
bool right2(Point a, Point L, Point R) { // 判断AL是否在AR右边（备用命名，保留原意）
    return sgn(cross(L - a, R - a)) > 0; // 必须严格大于零
}

int InTubao(vector<Point> &P, int n_local, Point a) { // 二分判断点是否在凸包内或上
    if (right2(P[1], a, P[2]) || right2(P[1], P[n_local], a))
        return 0; // 在P[1_2]或P[1_n]外

    if (checkP(a, P[1], P[2]) || checkP(a, P[1], P[n_local]))
        return 2; // 在P[1_2]或P[1_n]上

    int l = 2, r = n_local - 1;
    while (l < r) { // 二分找到一个位置pos使得P[1]_A在P[1_pos],P[1_(pos+1)]之间
        int mid = (l + r + 1) >> 1;
        if (right2(P[1], P[mid], a)) l = mid;
        else r = mid - 1;
    }
    if (right2(P[l], a, P[l + 1])) return 0; // 在P[pos_(pos+1)]外

    if (checkP(a, P[l], P[l + 1])) return 2; // 在P[pos_(pos+1)]上

    return 1;
}

/* ---------------- 半平面交 ---------------- */
vector<Line> L(N);
vector<Point> P1(N);
int tot;

bool jijiao_half(Line p, Line q) { // 极角排序+左侧排序（复用名字但保留原逻辑）
    double P = Atan2(p), Q = Atan2(q);
    return fabs(P - Q) > eps ? P < Q : cross(p.b - p.a, q.b - p.a) < 0;
}

int half_plane() { // 半平面交
    sort(L.begin() + 1, L.begin() + tot + 1, jijiao); // 极角排序
    vector<Line> dq(N);
    int t = 1, h = 1;
    dq[1] = L[1]; // 双端队列

    for (int i = 2; i <= tot; i++) {
        if (sgn(Atan2(L[i]) - Atan2(L[i - 1])) == 0) continue;
        while (h < t && Onright(L[i], getNodeL(dq[t], dq[t - 1]))) t--;
        while (h < t && Onright(L[i], getNodeL(dq[h], dq[h + 1]))) h++;
        dq[++t] = L[i];
    }
    while (h < t && Onright(dq[h], getNodeL(dq[t], dq[t - 1]))) t--;
    int cnt = 0;
    for (int i = h; i <= t; i++) {
        P1[++cnt] = getNodeL(dq[i], dq[i < t ? i + 1 : h]);
    }
    return cnt;
}
