时间：
O(n)：n <= 5e8
O(nlogn)：n <= 2e7
O(n^2)：n <= 2e4
O(n^3)：n <= 500

空间：
265MB = int a[67108864] (大概6e7)

一维数组转二维数组下标：y = idx % m, x = idx / m	
二维转一维：idx = m * x + y

C++ 向上取整: a / b = (a + b - 1) / b

builtin函数：https://www.luogu.com/article/0gvfhhdd

__builtin_popcount(x):二进制x中1的个数

__builtin_ffs(x):低位开始第一个 1 的位置
例x = 00000011000时，返回4

__builtin_ctz(x):后导零的个数

__builtin_clz(x):前导零的个数

线性求1~n逆元：
inv[1] = 1;
for (int i = 2; i <= n; i ++)
	inv[i] = (int)(p - (p / i) * (i64)inv[p % i] % p);//O(N) (p为mod)

set/map:
auto it = s.lower_bound(x) : 以x为下界的区间内的最小元素，即第一个 >= x 的迭代器(s.end()时为不存在)。
--it: 最大的 < x 的迭代器(s.begin()时为不存在)

auto it = s.upper_bound(x) : 以x为上界的区间外的最小元素，第一个 > x 的迭代器(s.end()时为不存在)。
--it: 最大的 <= x 的迭代器(s.begin()时为不存在)

随机化：
static mt19937_64 rng (
    chrono::steady_clock::now().time_since_epoch().count()
);
#define rand(l, r) (uniform_int_distribution<long long>((l),(r))(rng))

种子：mt19937_64;
生成一个l到r的随机数：rand(l, r);
随机打乱a数组：shuffle(a.begin(), a.end(), rng)

分解质因数优化：(n <= 1e7且不卡常时可做)
利用线性筛预先处理sqrt(n)个质数，然后枚举质数去分解即可，注意要判断除剩下的d大于1的话说明还要加上一个大于sqrt(n)的质数。