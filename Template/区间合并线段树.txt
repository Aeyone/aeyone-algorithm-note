struct Info{
    int mx = 0, pre = 0, suf = 0, pmx = 0, smn = 1e9, siz = 0;
};

Info operator+(const Info &l, const Info &r){
    if(l.siz == 0)
        return r;
    if(r.siz == 0)
        return l;
    
    Info res;
    res.mx = max(l.mx, r.mx);
    res.pre = l.pre, res.pmx = l.pmx;
    res.suf = r.suf, res.smn = r.smn;
    res.siz = l.siz + r.siz;

    if(l.smn > r.pmx){
        res.mx = max(res.mx, l.suf + r.pre);
        if(l.suf == l.siz)//头部贯通
            res.pre = l.siz + r.pre;
        if(r.pre == r.siz)//尾部贯通
            res.suf = l.suf + r.siz;
    }
    return res;
}

struct SegmentTree{
    int n;
    vector<Info> info;
 
    SegmentTree() {}
    SegmentTree(int _n, vector<int> &a) {
        init(_n, a);
    }   

    void init(int _n, vector<int> &a){
        n = _n;
        info.assign(n << 2, Info());
        build(1, 1, n, a);
    }

    Info merge(Info l, Info r){
        return (l + r);
    }
    
    void build(int p, int l, int r, vector<int> &a){
        if (l == r){
            info[p] = {1, 1, 1, a[l - 1], a[l - 1], 1};
        }else{
            int mid = (l + r) / 2;
            build(2 * p, l, mid, a);
            build(2 * p + 1, mid + 1, r, a);
            info[p] = merge(info[2 * p], info[2 * p + 1]);
        }
    }

    Info query(int p, int l, int r, int L, int R){
        if(L > r || R < l)
            return Info();
        
        if(L <= l && r <= R)
            return info[p];
        
        int mid = (l + r) / 2;
        Info Ql = query(2 * p, l, mid, L, R);
        Info Qr = query(2 * p + 1, mid + 1, r, L, R);
        return merge(Ql, Qr);
    }
    //1-based
    Info query(int L, int R){
        return query(1, 1, n, L, R);
    }
};